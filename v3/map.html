<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<link href="../GSMod.css" rel="stylesheet" type="text/css">
<link href="../progressbar.css" rel="stylesheet" type="text/css">
<script src="../jquery-2.1.0.min.js"></script>
<script src="../leap-0.6.0.min.js"></script>
<script src="../1euro.js"></script>
<script src="../jquery.popmenu.js"></script>
<link rel="stylesheet" href="lib/font-awesome/css/font-awesome.min.css"/>
<link rel="stylesheet" href="iconmoon.css"/>

<body>
<script src="../move.min.js"></script>
<script src="state-machine.js"></script>
<div id="map-canvas"></div>
<canvas id="leap-overlay-right" class="overlay"></canvas>
<canvas id="leap-overlay-left" class="overlay"></canvas>

<canvas id="touch-overlay" class="touch-overlay"></canvas>
<img id="item1" src="img/draw.png">
<img id="item2" src="img/navigation.png">
<img id="item3" src="img/clear.png">

<div id="menu_box_right">
    <div class="pop_ctrl" id="pop_ctrl_right"><i class="fa fa-bars"></i></div>
    <ul id="menu_box_right_ele">
        <li class="demo_li">
            <div><i class="fa icon-earth fa-2x"></i></div>
            <div>Satellite</div>
            </a></li>
        <li class="demo_li">
            <div><i class="fa fa-trash fa-2x"></i></div>
            <div>Clear</div>
        </li>
        <li class="demo_li">
            <div><i class="fa fa-pencil fa-2x"></i></div>
            <div>Shape</div>
        </li>
        <li class="demo_li">
            <div><i class="fa fa-car fa-2x"></i></div>
            <div>Route</div>
        </li>
        <li class="demo_li">
            <div><i class="fa fa-times fa-2x"></i></div>
            <div>Exit</div>
        </li>
    </ul>
</div>
<div id="menu_box_left">
    <div class="pop_ctrl" id="pop_ctrl_left"><i class="fa fa-bars"></i></div>
    <ul id="menu_box_left_ele">
        <li class="demo_li">
            <div><i class="fa fa-eye fa-2x"></i></div>
            <div>Something</div>
            </a></li>
        <li class="demo_li">
            <div><i class="fa fa-trash fa-2x"></i></div>
            <div>Something</div>
        </li>
        <li class="demo_li">
            <div><i class="fa fa-pencil fa-2x"></i></div>
            <div>Something</div>
        </li>
        <li class="demo_li">
            <div><i class="fa fa-car fa-2x"></i></div>
            <div>Something</div>
        </li>
        <li class="demo_li">
            <div><i class="fa fa-times fa-2x"></i></div>
            <div>Exit</div>
        </li>
    </ul>
</div>
</body>


<script src="../gestures.js"></script>
<script src="../GSMod.js"></script>
<script src="../gl-matrix.js"></script>
<script src="circular-progress.js"></script>
<script type="text/javascript"
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDf5Bggd6pUGScaAgQnt0HPwVhcLwV5fHU&sensor=false&language=en">
</script>
<script>
var canvasWidth = 0, canvasHeight = 0;
var ACCELERATION_FACTOR = 3;
var canvas;
var ctxRight;
var ctxLeft;
var canvasLeft;
var canvasRight;
var ctxTouch;
var CURSOR_SIZE = 30;
var cursorIdleTimeout = false;
var itemSelected = 1;
var leftItemSelected = 0;
var rightItemSelected = 0
function canvasApp() {

    var distanceAlphaProj = 1;


    var isCursorDown = false;
    var clickTimeout = true;
    canvasWidth = document.body.clientWidth;
    canvasHeight = document.body.clientHeight;

    canvasRight = document.getElementById("leap-overlay-right");
    // fullscreen
    canvasRight.width = 200 * CURSOR_SCALE;
    canvasRight.height = 200 * CURSOR_SCALE;
    ctxRight = canvasRight.getContext("2d");

    canvasLeft = document.getElementById("leap-overlay-left");
    // fullscreen
    canvasLeft.width = 200 * CURSOR_SCALE;
    canvasLeft.height = 200 * CURSOR_SCALE;
    ctxLeft = canvasLeft.getContext("2d");


    canvas = document.getElementById("touch-overlay");
    // fullscreen
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    ctxTouch = canvas.getContext("2d");

    touchMgr.touchMoveHandler = function (currentTouch, moveX, moveY) {
        if (currentTouch.whichhand == "left") {
            if (touchMgr.countTouches("left") == 1 && currentTouch.group == 0) {
                map.panBy(moveX, moveY);
            }
        }
    };

    touchMgr.afterTouchMoveHandler = function (currentTouch, moveX, moveY) {
        if (currentTouch.whichhand == "left") {
            if (touchMgr.countTouches("left") == 2 && currentTouch.group == 1) {
                var d = new Date().getTime();
                if (d - currentTouch.starttime < 150) return;
                ctxLeft.clearRect(0, 0, canvas.width, canvas.height);
                canvasLeft.style.top = touchMgr.leftGroupCtr[1] + "px";
                canvasLeft.style.left = touchMgr.leftGroupCtr[0] + "px";
                ctxLeft.save();
                ctxLeft.scale(CURSOR_SCALE, CURSOR_SCALE);
                utilities.drawZoom(ctxLeft);
                var offset = touchMgr.calculateCenter("left")[1] - touchMgr.leftGroupCtr[1];
                offset = Math.min(40, offset);
                var zoomRatio = offset / 40;
                zoomRatio /= 0.5;

                if (zoomTimeout) {
                    if (zoomRatio > .4) {
                        map.setZoom(map.getZoom() - 1);
                        zoomTimeout = false;
                        setTimeout(function () {
                            zoomTimeout = true;
                        }, 600 / Math.ceil(zoomRatio));
                    } else if (zoomRatio < -.4) {
                        zoomRatio = -zoomRatio;
                        map.setZoom(map.getZoom() + 1);
                        zoomTimeout = false;
                        setTimeout(function () {
                            zoomTimeout = true;
                        }, 600 / Math.ceil(zoomRatio));
                    }


                }
                ctxLeft.translate(0, touchMgr.calculateCenter("left")[1] - touchMgr.leftGroupCtr[1]);
                utilities.drawGeneric(ctxLeft);
                ctxLeft.restore();
            }
        }
    };

    touchMgr.touchEndHandler = function (currentTouch) {
        var d = new Date().getTime();

        if (touchMgr.countTouches(currentTouch.whichhand) == 1) {
            if (d - currentTouch.starttime < 150) {
                if (currentTouch.group == 1) {
                    //handle double tab
                    handleDoubleTab(currentTouch.whichhand, currentTouch.pageX, currentTouch.pageY);
                } else if (currentTouch.group == 0) {
                    //handle single tab
                    handleSingleTab(currentTouch.whichhand, currentTouch.pageX, currentTouch.pageY);

                }
            }
        }


    };

    leapDeviceMgr.initDevice(canvasWidth, canvasHeight);
    leapDeviceMgr.addDevice("localhost", "right", GESTURE_ALL_RIGHT, rightOnFrame);
    leapDeviceMgr.addDevice("192.168.20.128", "left", GESTURE_ALL_RIGHT, leftOnFrame);
    leapDeviceMgr.start();
    $('#menu_box_right').popmenu({'background': '#e67e22', 'focusColor': '#c0392b', 'iconSize': '100px', 'width': '500px'});
    $("#pop_ctrl_right").hide();

    $('#menu_box_left').popmenu({ 'iconSize': '100px', 'width': '100px'});
    $("#pop_ctrl_left").hide();
    $("#menu_box_left_ele li").click(function () {
        switch ($(this).find("div")[1].innerHTML) {
            case "Exit":
                closeMenu("left");
                break;
        }
    });
    $("#menu_box_right_ele li").click(function () {
        var shapeMgr = shapeManager.getInstance();
        switch ($(this).find("div")[1].innerHTML) {
            case "Exit":
                closeMenu("right");
                break;
            case "Satellite":
                map.setMapTypeId(google.maps.MapTypeId.SATELLITE);
                $(this).find("div")[1].innerHTML = "Roadmap";
                var element = $("#menu_box_right_ele li i.icon-earth")[0];
                $(element).removeClass("icon-earth").addClass("icon-map");
                break;
            case "Roadmap":
                map.setMapTypeId(google.maps.MapTypeId.ROADMAP);
                $(this).find("div")[1].innerHTML = "Satellite";
                var element = $("#menu_box_right_ele li i.icon-map")[0];
                $(element).addClass("icon-earth").removeClass("icon-map");
                break;
            case "Clear":
                shapeMgr.clearAllMarkers();
                break;
            case "Shape":
                shapeMgr.completeShape();
                break;
            case "Route":
                shapeMgr.completeRoute();
                break;

        }
    });


    startMap();

    function handleSingleTab(whichhand, pageX, pageY) {
        switch (whichhand) {
            case "right":
                shapeManager.getInstance().addCoordbyXY(pageX, pageY);
                break;
            case "left":
                break;
        }
    }

    function closeMenu(whichhand) {
        var elementStr = "#menu_box_" + whichhand + "_ele";
        $(elementStr).hide();
        $(window["canvas" + whichhand[0].toUpperCase() + whichhand.slice(1)]).css("zIndex", 200001);
    }

    function showMenu(whichhand, top, left, isLeap) {
        var elementStr = "#menu_box_" + whichhand + "_ele";
        var elementBoxStr = "#menu_box_" + whichhand;

        top = Math.min(canvasHeight - $(elementStr).height(), top);
        left = Math.min(canvasWidth - $(elementStr).width(), left);
        top = Math.max(0, top);
        left = Math.max(0, left);
        $(elementStr).show("fast");
        $(elementBoxStr).css("top", top + "px");
        $(elementBoxStr).css("left", left + "px");
        //some odd zindex issue due to chrome built-in swap gesture; had to temporarily surface cursor canvas
        if (isLeap)
            $(window["canvas" + whichhand[0].toUpperCase() + whichhand.slice(1)]).css("zIndex", 300000);
    }


    function handleDoubleTab(whichhand, pageX, pageY) {
        switch (whichhand) {
            case "right":
//                shapeManager.getInstance().addCoordbyXY(pageX, pageY);
//                    touchMgr.rightGroupCtr = [0,0];
                showMenu("right", touchMgr.rightGroupCtr[1], touchMgr.rightGroupCtr[0]);

                break;
            case "left":
//                touchMgr.leftGroupCtr = [0,0];


                showMenu("left", touchMgr.leftGroupCtr[1], touchMgr.leftGroupCtr[0]);
                break;
        }
    }


    function handleRightAnimation(controls) {
//        console.log("posture: "+controls.posture);
        var ctx = ctxRight;

        var screenX = -controls.x + canvasWidth;
        var screenY = -controls.y + canvasHeight;
        ctx.save();
        var ratio = utilities.getRatio(controls.palmPosition, controls.use);
        ctx.globalAlpha = 1 - ratio;
        canvasRight.style.top = screenY + "px";
        canvasRight.style.left = screenX + "px";
        ctx.scale(CURSOR_SCALE, CURSOR_SCALE);


        switch (controls.posture) {
            case "+thu+ind":
                closeWidgets(controls);
                closeMenu("right");

                var depthScale = controls.depthVal;
                distanceAlphaProj = controls.devianceVal;


                switch (controls.cursorState) {
                    case "active":
                        utilities.drawPoint(ctx);
                        break;
                    case "down":
                        if (isCursorDown) {
                            utilities.drawPoint(ctx);
                            utilities.drawDown(ctx);


                        } else {
                            utilities.drawPoint(ctx);
//                                ctx.fillStyle = "rgba(255,255,0,0.4)";
                        }

                        break;
                    case "dragging":
//                            ctx.fillStyle = "rgba(255,0,0,0.9)";
                        break;
                }

                window.clearTimeout(cursorIdleTimeout);
                cursorIdleTimeout = false;
                break;
            case "+ind":
                closeMenu("right");

                closeWidgets(controls);

                distanceAlphaProj = controls.devianceVal;

                var depthScale = controls.depthVal;

                utilities.drawClutch(ctx);

                if (!cursorIdleTimeout) {
                    cursorIdleTimeout = setTimeout(function () {
                        isCursorDown = false;
                    }, 600);
                }
                break;
            case "+thu":
                popupWidgets(controls);
                closeMenu("right");

                var rotatex = controls.palmNormal[0] * Math.PI * 180;
                // console.log(rotatex);
                if (rotatex < -70) {
                    itemSelected = 2;
                } else if (rotatex < 70) {
                    itemSelected = 1;
                } else {
                    itemSelected = 0;
                }
                selectWidget(controls, itemSelected);

                break;
            case "-rin-pin":

                showMenu("right", screenY, screenX, true);
                var offset = utilities.getAbsoluteOffset(controls.palmPosition, controls.use, controls.tag)[0];
                offset += $("#menu_box_right_ele").width() / 2;
                offset = Math.floor(offset / $("#menu_box_right_ele").height());
                var items = $("#menu_box_right_ele li");
                canvasRight.style.top = $(items[offset]).offset().top + $("#menu_box_right_ele").height() / 2 - 100 * CURSOR_SCALE + "px";
                canvasRight.style.left = $(items[offset]).offset().left + $("#menu_box_right_ele").height() / 2 - 100 * CURSOR_SCALE + "px";
                rightItemSelected = offset;
                utilities.drawGeneric(ctx);
                break;


            default :
                closeMenu("right");

                closeWidgets(controls);
                utilities.drawGeneric(ctx);
                isCursorDown = false;

        }
        var offset = utilities.getOffsetPosition(controls.palmPosition, controls.use);
        ctx.translate(-offset[0], -offset[1]);
        utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);


        ctx.restore();

    }

    function handleLeftEvent(controls) {
        switch (controls.cursorEvent) {
            case "clickup":

                switch (controls.posture) {

                    case "-rin-pin":
                        var items = $("#menu_box_left_ele li");

                        $(items[leftItemSelected]).trigger("click");
                        console.log("rinpin");
                        break;
                }

                console.log("clickup");
                controls.cursorEvent = "none";

                break;
            case "clickdown":

                break;

        }
    }

    function handleRightEvent(controls) {
        var shapeMgr = shapeManager.getInstance();
        switch (controls.cursorEvent) {
            case "clickup":
                if (clickTimeout && isCursorDown) {
                    switch (controls.posture) {
                        case "+thu+ind":
                            var cursorX = controls.x - 100 * CURSOR_SCALE;
                            var cursorY = controls.y - 100 * CURSOR_SCALE;
                            var screenX = canvas.width - cursorX;
                            var screenY = canvas.height - cursorY;
                            var point = new google.maps.Point(screenX, screenY);
                            var proj = map.getProjection();
                            var center = map.getCenter();
                            var centerPiWorld = proj.fromLatLngToPoint(center);
                            // centerPiWorld.x = centerPiWorld.x / 256 * canvas.width;
                            // centerPiWorld.y = centerPiWorld.y / 256 * canvas.height;

                            var centerPiLocalX = centerPiWorld.x * (Math.pow(2, map.getZoom()));
                            var centerPiLocalY = centerPiWorld.y * (Math.pow(2, map.getZoom()));

                            var panDelta = [
                                (cursorX - canvas.width / 2), (cursorY - canvas.height / 2)
                            ];


                            centerPiLocalX -= panDelta[0];
                            centerPiLocalY -= panDelta[1];
                            centerPiLocalX = centerPiLocalX / (Math.pow(2, map.getZoom()));
                            centerPiLocalY = centerPiLocalY / (Math.pow(2, map.getZoom()));

                            var newPoint = new google.maps.Point(centerPiLocalX, centerPiLocalY);
                            var newCoord = proj.fromPointToLatLng(newPoint);


                            shapeMgr.addCoord(newCoord);
                            break;
                        case "+thu":
                            switch (itemSelected) {
                                case 0:
                                    shapeMgr.completeShape();
                                    break;
                                case 1:
                                    shapeMgr.completeRoute();
                                    break;
                                case 2:
                                    shapeMgr.clearAllMarkers();
                                    break;

                            }
                            closeWidgets(controls);
                            break;
                        case "-rin-pin":
                            var items = $("#menu_box_right_ele li");

                            $(items[rightItemSelected]).trigger("click");
                            console.log("rinpin")
                            break;
                    }

                }
                clickTimeout = false;
                setTimeout(function () {
                    clickTimeout = true;
                }, 50);
                isCursorDown = false;

                controls.cursorEvent = "none";

                break;
            case "clickdown":
                if (clickTimeout) {

                    controls.cursorEvent = "none";
                    isCursorDown = true;
                }
                controls.cursorEvent = "none";
                break;

        }
    }

    function handleInvalidAnimation(controls) {
        var ctx;
        var screenX, screenY;

        var canvas;
        if (interstate.fsm.current === "twoTouches") {
            return;
        }
        if (controls.tag == "right") {
            if (interstate.fsm.current === "touchRightWait" || interstate.fsm.current === "touchRight") return;
            ctx = ctxRight;
            canvas = canvasRight;
            screenX = -controls.x + canvasWidth;
            screenY = -controls.y + canvasHeight;

            closeWidgets(controls);

        } else if (controls.tag == "left") {
            if (interstate.fsm.current === "touchLeftWait" || interstate.fsm.current === "touchLeft") return;
            ctx = ctxLeft;
            canvas = canvasLeft;
            screenX = 0;
            screenY = canvasHeight - CURSOR_SCALE * 200;

        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        canvas.style.top = screenY + "px";
        canvas.style.left = screenX + "px";
        ctx.scale(CURSOR_SCALE, CURSOR_SCALE);
        ctx.globalAlpha = 0.2;
        utilities.drawGeneric(ctx);
        var offset = utilities.getOffsetPosition(controls.palmPosition, controls.use);
        ctx.translate(-offset[0], -offset[1]);
        utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);

        ctx.restore();
//        console.log("invalid draing" + controls.fingerList);

    }

    var zoomTimeout = true;
    var olderLeftPosture = "none";

    function handleLeftAnimation(controls) {
        var ctx = ctxLeft;
        var offset = utilities.getOffsetPosition(controls.palmPosition, controls.use);

        var screenX = 0;
        var screenY = canvasHeight - CURSOR_SCALE * 200;


        ctx.save();
        var ratio = utilities.getRatio(controls.palmPosition, controls.use);
        ctx.globalAlpha = 1 - ratio;
//        ctx.translate(screenX, screenY);

        canvasLeft.style.top = screenY + "px";
        canvasLeft.style.left = screenX + "px";
        ctx.scale(CURSOR_SCALE, CURSOR_SCALE);
        switch (controls.posture) {
            case "+ind":
                closeMenu("left");
                if (olderLeftPosture !== "+ind") {
                    ctrPosY = controls.palmPosition[1];
                    ctrPosX = controls.palmPosition[0];
                }
                utilities.drawPan(ctx);
                var ballPos = drawNaviBall(ctx, controls.stablePalmPosition, controls.use, false);
                map.panBy(ballPos[0], ballPos[1]);

                ctx.translate(-offset[0] + ballPos[0], -offset[1] + ballPos[1]);

                utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);
                break;
            case "+thu+ind":
                closeMenu("left");
                if (olderLeftPosture !== "+thu+ind") {
                    ctrPosY = controls.palmPosition[1];
                    ctrPosX = controls.palmPosition[0];
                }
                utilities.drawZoom(ctx);
                var ballPos = drawNaviBall(ctx, controls.stablePalmPosition, controls.use, true);
                var offsetRange = 40;
                var zoomRatio = ballPos[1] / 40;
                zoomRatio /= 0.5;
                if (zoomTimeout) {
                    if (zoomRatio > 0) {
                        map.setZoom(map.getZoom() - 1);
                        zoomTimeout = false;
                        setTimeout(function () {
                            zoomTimeout = true;
                        }, 600 / Math.ceil(zoomRatio));
                    } else if (zoomRatio < 0) {
                        zoomRatio = -zoomRatio;
                        map.setZoom(map.getZoom() + 1);
                        zoomTimeout = false;
                        setTimeout(function () {
                            zoomTimeout = true;
                        }, 600 / Math.ceil(zoomRatio));
                    }

                }


                ctx.translate(-offset[0] + ballPos[0], -offset[1] + ballPos[1]);

                utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);
                break;
            case "-rin-pin":
                showMenu("left", canvasWidth / 2, canvasHeight / 2, true);
                var offset = utilities.getAbsoluteOffset(controls.palmPosition, controls.use, controls.tag)[1];
                offset += $("#menu_box_left_ele").height() / 2;
                offset = Math.floor(offset / $("#menu_box_left_ele").width());
                var items = $("#menu_box_left_ele li");
                canvasLeft.style.top = $(items[offset]).offset().top + $("#menu_box_left_ele").width() / 2 - 100 * CURSOR_SCALE + "px";
                canvasLeft.style.left = $(items[offset]).offset().left + $("#menu_box_left_ele").width() / 2 - 100 * CURSOR_SCALE + "px";
                leftItemSelected = offset;
                utilities.drawGeneric(ctx);
                utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);
                break;
            case "-thu":
                closeMenu("left");
                if (olderLeftPosture !== "-thu") {
                    ctrPosY = controls.palmPosition[1];
                    ctrPosX = controls.palmPosition[0];
                }
                utilities.drawFlickMenu(ctx);
                var ballPos = drawNaviBall(ctx, controls.stablePalmPosition, controls.use, true);


                utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);
                break;
            default :
                closeMenu("left");

                utilities.drawGeneric(ctx);
                ctx.translate(-offset[0], -offset[1]);
                utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);
        }
        olderLeftPosture = controls.posture;
        ctx.restore();
    }


    function rightOnFrame(controls) {

        if (controls.posture == "invalid" || !controls.valid) {
            handleInvalidAnimation(controls);
        } else {
            ctxRight.clearRect(0, 0, canvas.width, canvas.height);
            handleRightAnimation(controls);
            handleRightEvent(controls);
        }
//            console.log("right " + controls.posture);
        //debug purpose

    }

    function leftOnFrame(controls) {

        if (controls.posture == "invalid" || !controls.valid) {
            handleInvalidAnimation(controls);
        } else {
            ctxLeft.clearRect(0, 0, canvas.width, canvas.height);
            handleLeftAnimation(controls);
            handleLeftEvent(controls);
        }

    }


}


$(window).ready(canvasApp());


function startMap() {


//    initialize();
}

//Google Map Ini
var map;
var directionsService = new google.maps.DirectionsService();

function initialize() {
    var rendererOptions = {
        draggable: true,
        preserveViewport: true
    };
    directionsDisplay = new google.maps.DirectionsRenderer(rendererOptions);
    var mapOptions = {
        zoom: 5,
        panControl: false,
        zoomControl: true,
        streetViewControl: false,
        center: new google.maps.LatLng(39.958099, -75.167805),
        minZoom: 2
    };
    map = new google.maps.Map(document.getElementById('map-canvas'),
            mapOptions);
    directionsDisplay.setMap(map);
}
google.maps.event.addDomListener(window, 'load', initialize);


function Shape() {
    this.coords = new Array();
    this.addCoord = function (coord) {
        this.coords.push(coord);
    }
}


function smoothZoom(max, cnt) {
    if (cnt >= max) {
        return;
    }
    else {
        z = google.maps.event.addListener(map, 'zoom_changed', function (event) {
            google.maps.event.removeListener(z);
            smoothZoom(max, cnt + .1);
        });
        setTimeout(function () {
            map.setZoom(cnt)
        }, 80); // 80ms is what I found to work well on my system -- it might not work well on all systems
    }
    console.log(map.getCenter());
}

var shapeManager = (function () {

    // Instance stores a reference to the Singleton
    var instance;
    var isInMakerProgress = false;
    var currentShape;


    function init() {
        // Singleton

        // Private methods and variables

        var routeArray = new Array();
        var markersArray = new Array();

        var shapeArray = new Array();
        return {
            // Public methods and variables
            getShapeArray: function () {
                return shapeArray;
            },

            completeShape: function () {

                if (isInMakerProgress) {


                    var shapeDrawing = new google.maps.Polygon({
                        paths: currentShape.coords,
                        strokeColor: '#FF0000',
                        strokeOpacity: 0.8,
                        strokeWeight: 2,
                        fillColor: '#FF0000',
                        fillOpacity: 0.35,
                        editable: true
                    });
                    shapeArray.push(shapeDrawing);
                    shapeDrawing.setMap(map);
                    isInMakerProgress = false;

                    for (var i = 0; i < markersArray.length; i++) {
                        markersArray[i].setMap(null);
                    }
                    markersArray = [];
                }


            },

            completeRoute: function () {

                if (isInMakerProgress) {


                    var markers = currentShape.coords;
                    var start = markers[0];
                    var end = markers[markers.length - 1];
                    var waypointlist = new Array();
                    if (markers.length > 2) {


                        for (var i = 1; i < markers.length - 1; i++) {
                            markers[i]
                            var waypoint = {
                                location: markers[i],
                                stopover: false
                            };
                            waypointlist.push(waypoint);
                        }
                    }
                    var request = {
                        origin: start,
                        destination: end,
                        waypoints: waypointlist,
                        travelMode: google.maps.TravelMode.WALKING
                    };
                    directionsService.route(request, function (result, status) {
                        if (status == google.maps.DirectionsStatus.OK) {
                            directionsDisplay.setDirections(result);
                            routeArray.push(currentShape);
                            isInMakerProgress = false;

                            for (var i = 0; i < markersArray.length; i++) {
                                markersArray[i].setMap(null);
                            }
                            markersArray = [];
                        } else {

//                                showMsg("Route not found");

                        }
                    });


                }


            },

            addCoordbyXY: function (cursorX, cursorY) {

                var screenX = canvas.width - cursorX;
                var screenY = canvas.height - cursorY;
                var point = new google.maps.Point(screenX, screenY);
                var proj = map.getProjection();
                var center = map.getCenter();
                var centerPiWorld = proj.fromLatLngToPoint(center);
                // centerPiWorld.x = centerPiWorld.x / 256 * canvas.width;
                // centerPiWorld.y = centerPiWorld.y / 256 * canvas.height;

                var centerPiLocalX = centerPiWorld.x * (Math.pow(2, map.getZoom()));
                var centerPiLocalY = centerPiWorld.y * (Math.pow(2, map.getZoom()));

                var panDelta = [
                    (screenX - canvas.width / 2), (screenY - canvas.height / 2)
                ];


                centerPiLocalX -= panDelta[0];
                centerPiLocalY -= panDelta[1];
                centerPiLocalX = centerPiLocalX / (Math.pow(2, map.getZoom()));
                centerPiLocalY = centerPiLocalY / (Math.pow(2, map.getZoom()));

                var newPoint = new google.maps.Point(centerPiLocalX, centerPiLocalY);
                var newCoord = proj.fromPointToLatLng(newPoint);

                if (isInMakerProgress) {
                    currentShape.addCoord(newCoord);
                } else {
                    currentShape = new Shape();
                    currentShape.addCoord(newCoord);
                    isInMakerProgress = true;
                }
                var marker = new google.maps.Marker({
                    position: newCoord,
                    map: map,
                    draggable: true,
                    animation: google.maps.Animation.DROP,
                    title: "Shape maker"
                });


                markersArray.push(marker);
            },

            addCoord: function (coord) {

                if (isInMakerProgress) {
                    currentShape.addCoord(coord);
                } else {
                    currentShape = new Shape();
                    currentShape.addCoord(coord);
                    isInMakerProgress = true;
                }
                var marker = new google.maps.Marker({
                    position: coord,
                    map: map,
                    draggable: true,
                    animation: google.maps.Animation.DROP,
                    title: "Shape maker"
                });


                markersArray.push(marker);


            },

            clearAllMarkers: function () {
                for (var i = 0; i < markersArray.length; i++) {
                    markersArray[i].setMap(null);
                }
                markersArray = [];
                isInMakerProgress = false;
            },

            getCursorState: function () {
                return currentCursorState;
            },

            getCursor: function () {
                return cursor;
            }





        }
    }

    return {
        // Get the Singleton instance if one exists
        // or create one if it doesn't
        getInstance: function () {

            if (!instance) {
                instance = init();
            }

            return instance;
        }

    };

})();

isWidgetShown = false;
function popupWidgets(controls) {
    if (!isWidgetShown) {
        var cursorX = controls.x - 100 * CURSOR_SCALE;
        var cursorY = controls.y - 100 * CURSOR_SCALE;
        var item1 = document.getElementById("item1");
        var item2 = document.getElementById("item2");
        var item3 = document.getElementById("item3");

        var offset = -60;


        item1.style.top = offset + canvas.height - cursorY + 'px';
        item2.style.top = offset + canvas.height - cursorY + 'px';
        item3.style.top = offset + canvas.height - cursorY + 'px';
        item1.style.left = offset + canvas.width - cursorX + 'px';
        item2.style.left = offset + canvas.width - cursorX + 'px';
        item3.style.left = offset + canvas.width - cursorX + 'px';


        setTimeout(function () {

            item1.style.visibility = 'visible';
            item2.style.visibility = 'visible';
            item3.style.visibility = 'visible';

            isWidgetShown = true;
        }, 1);


    }

}

function selectWidget(controls, selectedId) {
    var cursorX = controls.x - 100 * CURSOR_SCALE;
    var cursorY = controls.y - 100 * CURSOR_SCALE;
    var scale = [.8, .8, .8];
    scale[selectedId] = 1.2;

    var marginX = 200;
    var marginY = 150;
    var yoffset = 50;
    var xoffset = -350;


    var item1 = document.getElementById("item1");
    var item2 = document.getElementById("item2");
    var item3 = document.getElementById("item3");

    if (cursorY + marginY > canvas.height) {
        marginY -= 300;
        yoffset = -yoffset;
    }
    if (cursorX + marginX > canvas.width) {
        item1.style.left = -xoffset + canvas.width - cursorX + 'px';
        item2.style.left = -xoffset + canvas.width - cursorX + 'px';
        item3.style.left = -xoffset + canvas.width - cursorX + 'px';
    } else if (cursorX - marginX < 0) {

        item1.style.left = xoffset + canvas.width - cursorX + 'px';
        item2.style.left = xoffset + canvas.width - cursorX + 'px';
        item3.style.left = xoffset + canvas.width - cursorX + 'px';

    }

    setTimeout(function () {

        move('#item1')
                .x(-marginX)
                .y(-marginY)
                .rotate(-45)
                .then()
                .scale(scale[0])
                .end();
        move('#item2')
                .x(0)
                .y(-marginY - yoffset)
                .scale(scale[1])
                .end();
        move('#item3')
                .x(marginX)
                .y(-marginY)
                .rotate(45)
                .scale(scale[2])
                .end();
    }, 1);
}

function closeWidgets(controls) {
    if (isWidgetShown) {
        var cursorX = controls.x - 100 * CURSOR_SCALE;
        var cursorY = controls.y - 100 * CURSOR_SCALE;
        var item1 = document.getElementById("item1");
        var item2 = document.getElementById("item2");
        var item3 = document.getElementById("item3");


        move('#item1')
                .x(200 / 10)
                .y(150 / 10)
                .scale(0.3)
                .end();
        move('#item2')
                .x(0 / 10)
                .y(200 / 10)
                .scale(0.3)
                .end();
        move('#item3')
                .x(-200 / 10)
                .y(150 / 10)
                .scale(0.3)
                .end();


        item1.style.visibility = 'hidden';
        item2.style.visibility = 'hidden';
        item3.style.visibility = 'hidden';
        isWidgetShown = false;


    }
    ;
}

var mapStateRight = (function () {
    var api = {};


    api.fsm = StateMachine.create({
        initial: 'idle',
        error: function (eventName, from, to, args, errorCode, errorMessage) {
            return 'event ' + eventName + ' was naughty :- ' + errorMessage;
        },
        events: [
            { name: 'addMarker', from: 'idle', to: 'drawing' },
            { name: 'complete', from: 'addMarker', to: 'idle' }

        ],
        callbacks: {

        }
    });


    return api;
})();

var naviBallPosX = 0;
var naviBallPosY = 0;
var bigCirR = 120;
var ballR = 50;
var smallCirR = 80;

function transferPointToLatLng() {
    var offset = .2;
    var neBound = map.getBounds().getNorthEast();
    var swBound = map.getBounds().getSouthWest();

    var proj = map.getProjection();

    var neBoundWorld = proj.fromLatLngToPoint(neBound);
    var swBoundWorld = proj.fromLatLngToPoint(swBound);
    // centerPiWorld.x = centerPiWorld.x / 256 * canvas.width;
    // centerPiWorld.y = centerPiWorld.y / 256 * canvas.height;

    var neBoundWorldX = neBoundWorld.x * (Math.pow(2, map.getZoom()));
    var neBoundWorldY = neBoundWorld.y * (Math.pow(2, map.getZoom()));

    neBoundWorldX -= canvasWidth * offset;
    neBoundWorldY -= canvasHeight * offset;

    neBoundWorldX = neBoundWorldX / (Math.pow(2, map.getZoom()));
    neBoundWorldY = neBoundWorldY / (Math.pow(2, map.getZoom()));

    var newNEBoundWorld = new google.maps.Point(neBoundWorldX, neBoundWorldY);
    var newNEBound = proj.fromPointToLatLng(newNEBoundWorld);

    var swBoundWorldX = neBoundWorld.x * (Math.pow(2, map.getZoom()));
    var swBoundWorldY = neBoundWorld.y * (Math.pow(2, map.getZoom()));

    swBoundWorldX += canvasWidth * offset;
    swBoundWorldY += canvasHeight * offset;

    swBoundWorldX = swBoundWorldX / (Math.pow(2, map.getZoom()));
    swBoundWorldY = swBoundWorldY / (Math.pow(2, map.getZoom()));

    var newSWBoundWorld = new google.maps.Point(swBoundWorldX, swBoundWorldY);
    var newSWBound = proj.fromPointToLatLng(newNEBoundWorld);

    var bounds = new google.maps.LatLngBounds();
    bounds.extend(newNEBound);
    bounds.extend(newSWBound);
    map.fitBounds(bounds);
}


var ctrPosY = 200;
var ctrPosX = 0;

function drawNaviBall(ctx, position, use, oneDirection) {
    ctx.save();
    var posX, posY;
    var radius = 80;
    var offsetRange = 40; //pixel ralated


    var threshold = .6;
    if (use == "wall") {
        posY = -(position[0] - ctrPosX);
        posX = -(position[1] - ctrPosY);
    } else {
        posX = (position[0] - ctrPosX);
        posY = -(position[1] - ctrPosY);
    }
    var pos = vec2.fromValues(posX, posY);


    var len = vec2.len(pos);
    if(len === 0) {
        utilities.drawGeneric(ctx);
        ctx.restore();
    return [0,0];
    }
    len = Math.min(len, radius);
    var ratio = len / radius;

    if (ratio > threshold) {
        ratio = (ratio - threshold) * 1 / (1 - threshold);

    } else {
        ratio = 0;
    } if(isNaN(pos[0])) {
        console.log("not a number")
    }


    vec2.scale(pos, pos, offsetRange * ratio / vec2.len(pos));
    pos[0] = oneDirection ? 0 : pos[0];
    ctx.translate(pos[0], pos[1]);
    utilities.drawGeneric(ctx);
    ctx.restore();

    return pos;
}

//document.addEventListener("touchstart", touchHandler, true);
//document.addEventListener("touchmove", touchHandler, true);
//document.addEventListener("touchend", touchHandler, true);
//document.addEventListener("touchcancel", touchHandler, true);

function touchHandler(event) {
    var touches = event.changedTouches,
            first = touches[0],
            type = "";
    switch (event.type) {
        case "touchstart":
            type = "mousedown";
            break;
        case "touchmove":
            type = "mousemove";
            break;
        case "touchend":
            type = "mouseup";
            break;
        default:
            return;
    }

    //initMouseEvent(type, canBubble, cancelable, view, clickCount,
    //           screenX, screenY, clientX, clientY, ctrlKey,
    //           altKey, shiftKey, metaKey, button, relatedTarget);

    var simulatedEvent = document.createEvent("MouseEvent");
    simulatedEvent.initMouseEvent(type, true, true, window, 1,
            first.screenX, first.screenY,
            first.clientX, first.clientY, false,
            false, false, false, 0/*left*/, null);

    first.target.dispatchEvent(simulatedEvent);
    event.preventDefault();
}

</script>
</html>
