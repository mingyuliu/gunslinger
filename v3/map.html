<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<link href="../GSMod.css" rel="stylesheet" type="text/css">
<link href="../progressbar.css" rel="stylesheet" type="text/css">
<script src="../jquery-2.1.0.min.js"></script>
<script src="../leap-0.6.0.min.js"></script>
<script src="../1euro.js"></script>


<body>
<script src="../move.min.js"></script>
<script src="state-machine.js"></script>
<div id="map-canvas"></div>
<canvas id="leap-overlay"></canvas>
<canvas id="leap-overlay2" class="overlay"></canvas>
<canvas id="leap-overlay3" class="overlay"></canvas>
<canvas id="touch-overlay" class="touch-overlay"></canvas>
<img id="item1" src="img/draw.png">
<img id="item2" src="img/navigation.png">
<img id="item3" src="img/clear.png">
</body>


<script src="../gestures.js"></script>
<script src="../GSMod.js"></script>
<script src="../gl-matrix.js"></script>
<script src="circular-progress.js"></script>
<script type="text/javascript"
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDf5Bggd6pUGScaAgQnt0HPwVhcLwV5fHU&sensor=false&language=en">
</script>
<script>
var canvasWidth = 0, canvasHeight = 0;
var ACCELERATION_FACTOR = 3;
var canvas;
var ctxRight;
var ctxLeft;
var ctxTouch;
var CURSOR_SIZE = 30;
var cursorIdleTimeout = false;
var itemSelected = 1;
function canvasApp() {

    var distanceAlphaProj = 1;


    var isCursorDown = false;
    var clickTimeout = true;
    canvasWidth = document.body.clientWidth;
    canvasHeight = document.body.clientHeight;

    canvas = document.getElementById("leap-overlay");
    // fullscreen
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    ctxRight = canvas.getContext("2d");

    canvas = document.getElementById("leap-overlay2");
    // fullscreen
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    ctxLeft = canvas.getContext("2d");

    canvas = document.getElementById("leap-overlay3");
    // fullscreen
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    canvas = document.getElementById("touch-overlay");
    // fullscreen
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    ctxTouch = canvas.getContext("2d");

    leapDeviceMgr.initDevice(canvasWidth, canvasHeight);
    leapDeviceMgr.addDevice("localhost", "right", GESTURE_ALL_RIGHT, rightOnFrame);
    leapDeviceMgr.addDevice("192.168.20.128", "left", GESTURE_ALL_RIGHT, leftOnFrame);
    leapDeviceMgr.start();

    var progressRight = new CircularProgress({
        radius: 35 * CURSOR_SCALE,
        strokeStyle: 'green',
        lineCap: 'round',
        lineWidth: 4
    });

    document.body.appendChild(progressRight.el);

    progressRight.el.style.position = "absolute";
    progressRight.el.style.zIndex = "500000000";


    progressRight.update(20);
    var progressLeft = new CircularProgress({
        radius: 35 * CURSOR_SCALE,
        strokeStyle: 'green',
        lineCap: 'round',
        lineWidth: 4
    });

    document.body.appendChild(progressLeft.el);

    progressLeft.el.style.position = "absolute";
    progressLeft.el.style.zIndex = "500000000";


    progressLeft.update(20);

    startMap();


    function handleRightAnimation(controls) {
//        console.log("posture: "+controls.posture);
        var ctx = ctxRight;

        var screenX = -controls.x + canvasWidth;
        var screenY = -controls.y + canvasHeight;
        ctx.save();
        var ratio = utilities.getRatio(controls.palmPosition, controls.use);
        ctx.globalAlpha = 1 - ratio;
        ctx.translate(screenX, screenY);
        ctx.scale(CURSOR_SCALE, CURSOR_SCALE);


        switch (controls.posture) {
            case "+thu+ind":
                closeWidgets(controls);
                var depthScale = controls.depthVal;
                distanceAlphaProj = controls.devianceVal;


                switch (controls.cursorState) {
                    case "active":
                        utilities.drawPoint(ctx);
                        break;
                    case "down":
                        if (isCursorDown) {
                            utilities.drawPoint(ctx);
                            utilities.drawDown(ctx);


                        } else {
                            utilities.drawPoint(ctx);
//                                ctx.fillStyle = "rgba(255,255,0,0.4)";
                        }

                        break;
                    case "dragging":
//                            ctx.fillStyle = "rgba(255,0,0,0.9)";
                        break;
                }

                window.clearTimeout(cursorIdleTimeout);
                cursorIdleTimeout = false;
                break;
            case "+ind":
                closeWidgets(controls);

                distanceAlphaProj = controls.devianceVal;

                var depthScale = controls.depthVal;

                utilities.drawClutch(ctx);

                if (!cursorIdleTimeout) {
                    cursorIdleTimeout = setTimeout(function () {
                        isCursorDown = false;
                    }, 600);
                }
                break;
            case "+thu":
                popupWidgets(controls);
                var rotatex = controls.palmNormal[0] * Math.PI * 180;
                // console.log(rotatex);
                if (rotatex < -70) {
                    itemSelected = 2;
                } else if (rotatex < 70) {
                    itemSelected = 1;
                } else {
                    itemSelected = 0;
                }
                selectWidget(controls, itemSelected);

                break;

            default :
                closeWidgets(controls);

                utilities.drawGeneric(ctx);
                isCursorDown = false;

        }
        var offset = utilities.getOffsetPosition(controls.palmPosition, controls.use);
        ctx.translate(-offset[0], -offset[1]);
        utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);

        progressRight.el.style.top = screenY + (-offset[1] + 65) * CURSOR_SCALE + "px";
        progressRight.el.style.left = screenX + (-offset[0] + 65) * CURSOR_SCALE + "px";
        if (controls.confidence >= 80) {
            progressRight.options["strokeStyle"] = "green";
        } else if (controls.confidence < 80 && controls.confidence >= 40) {
            progressRight.options["strokeStyle"] = "yellow";
        } else if (controls.confidence < 40 && controls.confidence > 0) {
            progressRight.options["strokeStyle"] = "red";
        } else {
            progressRight.options["strokeStyle"] = "grey";
        }
        progressRight.update(controls.confidence / 4);
        ctx.restore();

    }

    function handleRightEvent(controls) {
        var shapeMgr = shapeManager.getInstance();
        switch (controls.cursorEvent) {
            case "clickup":
                if (clickTimeout && isCursorDown) {
                    switch (controls.posture) {
                        case "+thu+ind":
                            var cursorX = controls.x - 100 * CURSOR_SCALE;
                            var cursorY = controls.y - 100 * CURSOR_SCALE;
                            var screenX = canvas.width - cursorX;
                            var screenY = canvas.height - cursorY;
                            var point = new google.maps.Point(screenX, screenY);
                            var proj = map.getProjection();
                            var center = map.getCenter();
                            var centerPiWorld = proj.fromLatLngToPoint(center);
                            // centerPiWorld.x = centerPiWorld.x / 256 * canvas.width;
                            // centerPiWorld.y = centerPiWorld.y / 256 * canvas.height;

                            var centerPiLocalX = centerPiWorld.x * (Math.pow(2, map.getZoom()));
                            var centerPiLocalY = centerPiWorld.y * (Math.pow(2, map.getZoom()));

                            var panDelta = [
                                (cursorX - canvas.width / 2), (cursorY - canvas.height / 2)
                            ];


                            centerPiLocalX -= panDelta[0];
                            centerPiLocalY -= panDelta[1];
                            centerPiLocalX = centerPiLocalX / (Math.pow(2, map.getZoom()));
                            centerPiLocalY = centerPiLocalY / (Math.pow(2, map.getZoom()));

                            var newPoint = new google.maps.Point(centerPiLocalX, centerPiLocalY);
                            var newCoord = proj.fromPointToLatLng(newPoint);


                            shapeMgr.addCoord(newCoord);
                            break;
                        case "+thu":
                            switch (itemSelected) {
                                case 0:
                                    shapeMgr.completeShape();
                                    break;
                                case 1:
                                    shapeMgr.completeRoute();
                                    break;
                                case 2:
                                    shapeMgr.clearAllMarkers();
                                    break;

                            }
                            closeWidgets(controls);
                            break;
                    }

                }
                clickTimeout = false;
                setTimeout(function () {
                    clickTimeout = true;
                }, 50);
                isCursorDown = false;

                controls.cursorEvent = "none";

                break;
            case "clickdown":
                if (clickTimeout) {

                    controls.cursorEvent = "none";
                    isCursorDown = true;
                }
                controls.cursorEvent = "none";
                break;

        }
    }

    function handleInvalidAnimation(controls) {
        var ctx;
        var screenX, screenY;
        var progressEle;
        if (controls.tag == "right") {
            ctx = ctxRight;
            screenX = -controls.x + canvasWidth;
            screenY = -controls.y + canvasHeight;
            progressEle = progressRight;
            closeWidgets(controls);

        } else if (controls.tag == "left") {
            ctx = ctxLeft;
            screenX = 0;
            screenY = canvasHeight - CURSOR_SCALE * 200;
            progressEle = progressLeft;
        }
        ctx.save();
        ctx.translate(screenX, screenY);
        ctx.scale(CURSOR_SCALE, CURSOR_SCALE);
        ctx.globalAlpha = 0.2;
        utilities.drawGeneric(ctx);
        var offset = utilities.getOffsetPosition(controls.palmPosition, controls.use);
        ctx.translate(-offset[0], -offset[1]);
        utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);
        progressEle.el.style.top = screenY + (-offset[1] + 65) * CURSOR_SCALE + "px";
        progressEle.el.style.left = screenX + (-offset[0] + 65) * CURSOR_SCALE + "px";
        ctx.restore();
//        console.log("invalid draing" + controls.fingerList);

    }

    var zoomTimeout = true;
    var olderLeftPosture = "none";

    function handleLeftAnimation(controls) {
        var ctx = ctxLeft;
        var offset = utilities.getOffsetPosition(controls.palmPosition, controls.use);

        var screenX = 0;
        var screenY = canvasHeight - CURSOR_SCALE * 200;

        if (controls.confidence >= 80) {
            progressLeft.options["strokeStyle"] = "green";
        } else if (controls.confidence < 80 && controls.confidence >= 40) {
            progressLeft.options["strokeStyle"] = "yellow";
        } else if (controls.confidence < 40 && controls.confidence > 0) {
            progressLeft.options["strokeStyle"] = "red";
        } else {
            progressLeft.options["strokeStyle"] = "grey";
        }
        progressLeft.update(controls.confidence / 4);
        ctx.save();
        var ratio = utilities.getRatio(controls.palmPosition, controls.use);
        ctx.globalAlpha = 1 - ratio;
        ctx.translate(screenX, screenY);
        ctx.scale(CURSOR_SCALE, CURSOR_SCALE);
        switch (controls.posture) {
            case "+ind":
                if (olderLeftPosture !== "+ind") {
                        ctrPosY = controls.palmPosition[1];
                        ctrPosX = controls.palmPosition[0];
                }
                utilities.drawPan(ctx);
                var ballPos = drawNaviBall(ctx, controls.stablePalmPosition, controls.use, false);
                map.panBy(ballPos[0], ballPos[1]);

                ctx.translate(-offset[0] + ballPos[0], -offset[1] + ballPos[1]);
                progressLeft.el.style.top = screenY + (-offset[1] + ballPos[1] + 65) * CURSOR_SCALE + "px";
                progressLeft.el.style.left = screenX + (-offset[0] + ballPos[0] + 65) * CURSOR_SCALE + "px";
                utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);
                break;
            case "+thu+ind":
                if (olderLeftPosture !== "+thu+ind") {
                    ctrPosY = controls.palmPosition[1];
                    ctrPosX = controls.palmPosition[0];
                }
                utilities.drawZoom(ctx);
                var ballPos = drawNaviBall(ctx, controls.stablePalmPosition, controls.use, true);
                var offsetRange = 40;
                var zoomRatio = ballPos[1] / 40;
                zoomRatio /= 0.5;
                if (zoomRatio !== 0 && zoomTimeout) {
                    map.setZoom(map.getZoom() + Math.ceil(zoomRatio));


                    zoomTimeout = false;
                    setTimeout(function () {
                        zoomTimeout = true;
                    }, 250);

                }


                ctx.translate(-offset[0] + ballPos[0], -offset[1] + ballPos[1]);
                progressLeft.el.style.top = screenY + (-offset[1] + ballPos[1] + 65) * CURSOR_SCALE + "px";
                progressLeft.el.style.left = screenX + (-offset[0] + ballPos[0] + 65) * CURSOR_SCALE + "px";
                utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);
                break;

            default :
                progressLeft.el.style.top = screenY + (-offset[1] + 65) * CURSOR_SCALE + "px";
                progressLeft.el.style.left = screenX + (-offset[0] + 65) * CURSOR_SCALE + "px";

                utilities.drawGeneric(ctx);
                ctx.translate(-offset[0], -offset[1]);
                utilities.drawRingnFingers(ctx, controls.fingerList, controls.tag);
        }
        olderLeftPosture = controls.posture;
        ctx.restore();
    }


    function rightOnFrame(controls) {
        ctxRight.clearRect(0, 0, canvas.width, canvas.height);
        leapDeviceMgr.printInfo(controls.posture);
        if (controls.posture == "invalid" || !controls.valid) {
            handleInvalidAnimation(controls);
        } else {
            handleRightAnimation(controls);
            handleRightEvent(controls);
        }
//            console.log("right " + controls.posture);

    }

    function leftOnFrame(controls) {
        ctxLeft.clearRect(0, 0, canvas.width, canvas.height);

        if (controls.posture == "invalid" || !controls.valid) {
            handleInvalidAnimation(controls);
        } else {
            handleLeftAnimation(controls);
            //handleLeftEvent(controls);
        }

    }


}


$(window).ready(canvasApp());


function startMap() {


//    initialize();
}

//Google Map Ini
var map;
var directionsService = new google.maps.DirectionsService();

function initialize() {
    var rendererOptions = {
        draggable: true,
        preserveViewport: true
    };
    directionsDisplay = new google.maps.DirectionsRenderer(rendererOptions);
    var mapOptions = {
        zoom: 5,
        panControl: false,
        zoomControl: true,
        streetViewControl: false,
        center: new google.maps.LatLng(39.958099, -75.167805)
    };
    map = new google.maps.Map(document.getElementById('map-canvas'),
            mapOptions);
    directionsDisplay.setMap(map);
}
google.maps.event.addDomListener(window, 'load', initialize);


function Shape() {
    this.coords = new Array();
    this.addCoord = function (coord) {
        this.coords.push(coord);
    }
}


function smoothZoom(max, cnt) {
    if (cnt >= max) {
        return;
    }
    else {
        z = google.maps.event.addListener(map, 'zoom_changed', function (event) {
            google.maps.event.removeListener(z);
            smoothZoom(max, cnt + .1);
        });
        setTimeout(function () {
            map.setZoom(cnt)
        }, 80); // 80ms is what I found to work well on my system -- it might not work well on all systems
    }
    console.log(map.getCenter());
}

var shapeManager = (function () {

    // Instance stores a reference to the Singleton
    var instance;
    var isInMakerProgress = false;
    var currentShape;


    function init() {
        // Singleton

        // Private methods and variables
        var shapeArray = new Array();
        var routeArray = new Array();
        var markersArray = new Array();

        return {

            // Public methods and variables
            completeShape: function () {

                if (isInMakerProgress) {

                    shapeArray.push(currentShape);

                    var shapeDrawing = new google.maps.Polygon({
                        paths: currentShape.coords,
                        strokeColor: '#FF0000',
                        strokeOpacity: 0.8,
                        strokeWeight: 2,
                        fillColor: '#FF0000',
                        fillOpacity: 0.35,
                        editable: true
                    });
                    shapeDrawing.setMap(map);
                    isInMakerProgress = false;

                    for (var i = 0; i < markersArray.length; i++) {
                        markersArray[i].setMap(null);
                    }
                    markersArray = [];
                }


            },

            completeRoute: function () {

                if (isInMakerProgress) {


                    var markers = currentShape.coords;
                    var start = markers[0];
                    var end = markers[markers.length - 1];
                    var waypointlist = new Array();
                    if (markers.length > 2) {


                        for (var i = 1; i < markers.length - 1; i++) {
                            markers[i]
                            var waypoint = {
                                location: markers[i],
                                stopover: false
                            };
                            waypointlist.push(waypoint);
                        }
                    }
                    var request = {
                        origin: start,
                        destination: end,
                        waypoints: waypointlist,
                        travelMode: google.maps.TravelMode.WALKING
                    };
                    directionsService.route(request, function (result, status) {
                        if (status == google.maps.DirectionsStatus.OK) {
                            directionsDisplay.setDirections(result);
                            routeArray.push(currentShape);
                            isInMakerProgress = false;

                            for (var i = 0; i < markersArray.length; i++) {
                                markersArray[i].setMap(null);
                            }
                            markersArray = [];
                        } else {

//                                showMsg("Route not found");

                        }
                    });


                }


            },

            addCoord: function (coord) {

                if (isInMakerProgress) {
                    currentShape.addCoord(coord);
                } else {
                    currentShape = new Shape();
                    currentShape.addCoord(coord);
                    isInMakerProgress = true;
                }
                var marker = new google.maps.Marker({
                    position: coord,
                    map: map,
                    draggable: true,
                    animation: google.maps.Animation.DROP,
                    title: "Shape maker"
                });


                markersArray.push(marker);


            },

            clearAllMarkers: function () {
                for (var i = 0; i < markersArray.length; i++) {
                    markersArray[i].setMap(null);
                }
                markersArray = [];
                isInMakerProgress = false;
            },

            getCursorState: function () {
                return currentCursorState;
            },

            getCursor: function () {
                return cursor;
            }



        }
    }

    return {
        // Get the Singleton instance if one exists
        // or create one if it doesn't
        getInstance: function () {

            if (!instance) {
                instance = init();
            }

            return instance;
        }

    };

})();

isWidgetShown = false;
function popupWidgets(controls) {
    if (!isWidgetShown) {
        var cursorX = controls.x - 100 * CURSOR_SCALE;
        var cursorY = controls.y - 100 * CURSOR_SCALE;
        var item1 = document.getElementById("item1");
        var item2 = document.getElementById("item2");
        var item3 = document.getElementById("item3");

        var offset = -60;


        item1.style.top = offset + canvas.height - cursorY + 'px';
        item2.style.top = offset + canvas.height - cursorY + 'px';
        item3.style.top = offset + canvas.height - cursorY + 'px';
        item1.style.left = offset + canvas.width - cursorX + 'px';
        item2.style.left = offset + canvas.width - cursorX + 'px';
        item3.style.left = offset + canvas.width - cursorX + 'px';


        setTimeout(function () {

            item1.style.visibility = 'visible';
            item2.style.visibility = 'visible';
            item3.style.visibility = 'visible';

            isWidgetShown = true;
        }, 1);


    }

}

function selectWidget(controls, selectedId) {
    var cursorX = controls.x - 100 * CURSOR_SCALE;
    var cursorY = controls.y - 100 * CURSOR_SCALE;
    var scale = [.8, .8, .8];
    scale[selectedId] = 1.2;

    var marginX = 200;
    var marginY = 150;
    var yoffset = 50;
    var xoffset = -350;


    var item1 = document.getElementById("item1");
    var item2 = document.getElementById("item2");
    var item3 = document.getElementById("item3");

    if (cursorY + marginY > canvas.height) {
        marginY -= 300;
        yoffset = -yoffset;
    }
    if (cursorX + marginX > canvas.width) {
        item1.style.left = -xoffset + canvas.width - cursorX + 'px';
        item2.style.left = -xoffset + canvas.width - cursorX + 'px';
        item3.style.left = -xoffset + canvas.width - cursorX + 'px';
    } else if (cursorX - marginX < 0) {

        item1.style.left = xoffset + canvas.width - cursorX + 'px';
        item2.style.left = xoffset + canvas.width - cursorX + 'px';
        item3.style.left = xoffset + canvas.width - cursorX + 'px';

    }

    setTimeout(function () {

        move('#item1')
                .x(-marginX)
                .y(-marginY)
                .rotate(-45)
                .then()
                .scale(scale[0])
                .end();
        move('#item2')
                .x(0)
                .y(-marginY - yoffset)
                .scale(scale[1])
                .end();
        move('#item3')
                .x(marginX)
                .y(-marginY)
                .rotate(45)
                .scale(scale[2])
                .end();
    }, 1);
}

function closeWidgets(controls) {
    if (isWidgetShown) {
        var cursorX = controls.x - 100 * CURSOR_SCALE;
        var cursorY = controls.y - 100 * CURSOR_SCALE;
        var item1 = document.getElementById("item1");
        var item2 = document.getElementById("item2");
        var item3 = document.getElementById("item3");


        move('#item1')
                .x(200 / 10)
                .y(150 / 10)
                .scale(0.3)
                .end();
        move('#item2')
                .x(0 / 10)
                .y(200 / 10)
                .scale(0.3)
                .end();
        move('#item3')
                .x(-200 / 10)
                .y(150 / 10)
                .scale(0.3)
                .end();


        item1.style.visibility = 'hidden';
        item2.style.visibility = 'hidden';
        item3.style.visibility = 'hidden';
        isWidgetShown = false;


    }
    ;
}

var mapStateRight = (function () {
    var api = {};


    api.fsm = StateMachine.create({
        initial: 'idle',
        error: function (eventName, from, to, args, errorCode, errorMessage) {
            return 'event ' + eventName + ' was naughty :- ' + errorMessage;
        },
        events: [
            { name: 'addMarker', from: 'idle', to: 'drawing' },
            { name: 'complete', from: 'addMarker', to: 'idle' }

        ],
        callbacks: {

        }
    });


    return api;
})();

var naviBallPosX = 0;
var naviBallPosY = 0;
var bigCirR = 120;
var ballR = 50;
var smallCirR = 80;

function transferPointToLatLng() {
    var offset = .2;
    var neBound = map.getBounds().getNorthEast();
    var swBound = map.getBounds().getSouthWest();

    var proj = map.getProjection();

    var neBoundWorld = proj.fromLatLngToPoint(neBound);
    var swBoundWorld = proj.fromLatLngToPoint(swBound);
    // centerPiWorld.x = centerPiWorld.x / 256 * canvas.width;
    // centerPiWorld.y = centerPiWorld.y / 256 * canvas.height;

    var neBoundWorldX = neBoundWorld.x * (Math.pow(2, map.getZoom()));
    var neBoundWorldY = neBoundWorld.y * (Math.pow(2, map.getZoom()));

    neBoundWorldX -= canvasWidth * offset;
    neBoundWorldY -= canvasHeight * offset;

    neBoundWorldX = neBoundWorldX / (Math.pow(2, map.getZoom()));
    neBoundWorldY = neBoundWorldY / (Math.pow(2, map.getZoom()));

    var newNEBoundWorld = new google.maps.Point(neBoundWorldX, neBoundWorldY);
    var newNEBound = proj.fromPointToLatLng(newNEBoundWorld);

    var swBoundWorldX = neBoundWorld.x * (Math.pow(2, map.getZoom()));
    var swBoundWorldY = neBoundWorld.y * (Math.pow(2, map.getZoom()));

    swBoundWorldX += canvasWidth * offset;
    swBoundWorldY += canvasHeight * offset;

    swBoundWorldX = swBoundWorldX / (Math.pow(2, map.getZoom()));
    swBoundWorldY = swBoundWorldY / (Math.pow(2, map.getZoom()));

    var newSWBoundWorld = new google.maps.Point(swBoundWorldX, swBoundWorldY);
    var newSWBound = proj.fromPointToLatLng(newNEBoundWorld);

    var bounds = new google.maps.LatLngBounds();
    bounds.extend(newNEBound);
    bounds.extend(newSWBound);
    map.fitBounds(bounds);
}


var ctrPosY = 200;
var ctrPosX = 0;

function drawNaviBall(ctx, position, use, oneDirection) {
    ctx.save();
    var posX, posY;
    var radius = 60;
    var offsetRange = 40; //pixel ralated


    var threshold = .8;
    if (use == "wall") {
        posY = -(position[0] - ctrPosX);
        posX = -(position[1] - ctrPosY);
    } else {
        posX = (position[0] - ctrPosX);
        posY = -(position[1] - ctrPosY);
    }
    var pos = vec2.fromValues(posX, posY);

    var len = vec2.len(pos);
    len = Math.min(len, radius);
    var ratio = len / radius;

    if (ratio > threshold) {
        ratio = (ratio - threshold) * 1 / (1 - threshold);

    } else {
        ratio = 0;
    }


    vec2.scale(pos, pos, offsetRange * ratio / vec2.len(pos));
    pos[0] = oneDirection ? 0 : pos[0];
    ctx.translate(pos[0], pos[1]);
    utilities.drawGeneric(ctx);
    ctx.restore();
    return pos;
}


</script>
</html>
